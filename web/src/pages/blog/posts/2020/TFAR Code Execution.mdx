---
title: TFAR Code Execution
description: |
    Everyone who has played Arma for an extended period has come across TFAR,
    Task Force Arrowhead Radio. I am not going to go into...
slug: tfar-code-execution
---

Everyone who has played Arma for an extended period has come across TFAR, 
[Task Force Arrowhead Radio]. While I am not going to go into how the mod works, 
I am going to dive directly into the code that drives TFAR, 
and do my best at explaining a type of lazy eval code execution that 
is much more complex than the previous [Lazy Eval Exploit] I covered. 
If you do not know what Lazy Evaluation is, I recommend reading that previous 
post to get a grasp on this style of exploit. To best explain my logic, 
I am going to take you down the path of how I figured out this exploit. 
It's going to be different than how I normally explain exploits. 
Hopefully, at the end of this, you'll understand how the TFAR exploit works, 
and how I created it from my initial thought.

---

The way I find exploits is by opening up a mod and looking through all of
its scripts for a few identifiers that could point to a vulnerability.
This is what I did for TFAR. Opening up the script files, I was looking
for any lazy eval exploits. One of the identifiers I use for lazy eval
exploits is `A and B`, where B is a variable. If B is a variable, there is a 
possibility that I can change the value of it, thus allowing a 
lazy eval code execution. Very often this identifier leads 
to a dead end. Either the variable is hard-coded or I cannot manipulate it. 
While looking at TFAR's files, I came across `fn_onLRTangentReleasedHack.sqf` 
which contains 3 instances of this identifier. Let me show you the code.

```sqf
#include "script.h"
private ["_scancode", "_mods", "_keybind", "_scancode_lr"];
_scancode = _this select 1; 
_keybind = ["TFAR", "LRTransmit"] call cba_fnc_getKeybind;
if !(isNil "_keybind") then {
	_mods = ((_keybind) select 5) select 1;
	_scancode_lr = ((_keybind) select 5) select 0;
	
	if (((_scancode == SHIFTL) and (_mods select 0))
	   or ((_scancode == CTRLL) and (_mods select 1))
	   or ((_scancode == ALTL) and (_mods select 2))
	   or (_scancode == _scancode_lr))
	then {	
		call TFAR_fnc_onLRTangentReleased;
	};
};
false
```

Here we can see the following identifiers:

- `(_scancode == SHIFTL) and (_mods select 0)`
- `(_scancode == CTRLL) and (_mods select 1)`
- `(_scancode == ALTL) and (_mods select 2)`

What this is telling me is that, if I can change the value of `_mods`, 
I can execute code through any of these fields. My next step is to figure 
out what SQF code determines the value of these fields.

Looking again at the code, `_mods` comes from `_keybind`, and `_keybind`
comes from `CBA_fnc_getKeybind`. So we have a clue. If we can control the 
output of CBA's `CBA_fnc_getKeybind` function, we can exploit this function! 
Let's take a look at `CBA_fnc_getKeybind`. 

> Quick warning, you will see comments in the code. 
> These comments describe how the exploit works, 
> and I'll get into them towards the end.

```sqf
#include "script_component.hpp"

params ["_addon", "_addonAction"];
TRACE_2("getKeybind",_addon,_addonAction);

if (!hasInterface) exitWith {nil};

private _action = toLower format ["%1$%2", _addon, _addonAction];

//because keybind value is a reference, it is linked to profilenamespace
private _actionInfo = GVAR(actions) getVariable _action; 

if (isNil "_actionInfo") exitWith {
    TRACE_2("Action not found",_action,_actionInfo);
    nil
};

_actionInfo params ["_displayName", "", "_keybinds", "", "_downCode", "_upCode", "_holdKey", "_holdDelay"];
TRACE_2("",_displayName,_keybinds);

//note that this does not have any type checks, just a default value
private _oldKeyBind = _keybinds param [0, [-1, [false, false, false]]];

[_addon, _addonAction, _displayName, _downCode, _upCode, _oldKeyBind, _holdKey, _holdDelay, _keybinds]
```

Looking back at TFAR's code, we can see that the item in index 5 is where 
`_mods` is derrived from. So the first thing I look at in `CBA_fnc_getKeybind` 
is the return value. Index 5 of this return value is `_oldKeybind`. 
Working backwards, `_oldKeybind` is index 0 of `_keybinds`. Quickly, checking
out that line, we can see that param does not have a default type or any
checks on the internal data types. Great, so now we just need to modify 
`_keybinds`. Looking at line 16, we can see `_keybinds` is at the 2nd index 
of `_actionInfo`.

Finally, we come to the point at which the complexity of this exploit increases.
`_actionInfo` is set by `GVAR(actions) getVariable _action`. `_action` is a 
string formatted by our input parameters. So we can conclude, 
`_action = "tfar$lrtransmit"` based on the input parameters of 
`CBA_fnc_getKeybind` (this is important and will be used later). 

But what is `GVAR(actions)`?

If we can modify `GVAR(actions)`, then we can change the values of our specific
actions keybind. To do so, we must take a look at CBA's `CBA_fnc_addKeybind`
function. I will point out snippets from `CBA_fnc_addKeybind`, so no need to
read the full function below.

```sqf
#include "script_component.hpp"
/* ----------------------------------------------------------------------------
Function: CBA_fnc_addKeybind

Description:
    Adds or updates the keybind handler for a specified mod action, and associates
    a function with that keybind being pressed.

    This file should be included for readable DIK codes:
        #include "\a3\ui_f\hpp\defineDIKCodes.inc"

    Additional DIK codes usable with this function:
        0xF0: Left mouse button
        0xF1: Right mouse button
        0xF2: Middle mouse button
        0xF3: Mouse #4
        0xF4: Mouse #5
        0xF5: Mouse #6
        0xF6: Mouse #7
        0xF7: Mouse #8
        0xF8: Mouse wheel up
        0xF9: Mouse wheel down

        0xFA: Custom user action 1
        0xFB: Custom user action 2
        0xFC: Custom user action 3
        0xFD: Custom user action 4
        0xFE: Custom user action 5
        0xFF: Custom user action 6
        0x100: Custom user action 7
        0x101: Custom user action 8
        0x102: Custom user action 9
        0x103: Custom user action 10
        0x104: Custom user action 11
        0x105: Custom user action 12
        0x106: Custom user action 13
        0x107: Custom user action 14
        0x108: Custom user action 15
        0x109: Custom user action 16
        0x10A: Custom user action 17
        0x10B: Custom user action 18
        0x10C: Custom user action 19
        0x10D: Custom user action 20

Parameters:
    _addon          - Name of the registering mod + optional sub-category <STRING, ARRAY>
    _action         - Id of the key action. <STRING>
    _title          - Pretty name, or an array of pretty name and tooltip <STRING>
    _downCode       - Code for down event, empty string for no code. <CODE>
    _upCode         - Code for up event, empty string for no code. <CODE>

Optional:
    _defaultKeybind - The keybinding data in the format [DIK, [shift, ctrl, alt]] <ARRAY>
    _holdKey        - Will the key fire every frame while down <BOOLEAN>
    _holdDelay      - How long after keydown will the key event fire, in seconds. <NUMBER>
    _overwrite      - Overwrite any previously stored default keybind <BOOLEAN>

Returns:
    Returns the current keybind for the action <ARRAY>

Examples:
    (begin example)
        // Register a simple keypress to an action
        #include "\a3\ui_f\hpp\defineDIKCodes.inc"

        ["MyMod", "MyKey", ["My Pretty Key Name", "My Pretty Tool Tip"], {
            _this call mymod_fnc_keyDown
        }, {
            _this call mymod_fnc_keyUp
        }, [DIK_TAB, [false, false, false]]] call CBA_fnc_addKeybind;

        ["MyMod", "MyOtherKey", "My Other Pretty Key Name", {
            _this call mymod_fnc_keyDownOther
        }, {
            _this call mymod_fnc_keyUpOther
        }, [DIK_K, [false, false, false]]] call CBA_fnc_addKeybind;
    (end example)

Author:
    Taosenai & Nou, commy2
---------------------------------------------------------------------------- */

// clients only.
if (!hasInterface) exitWith {};

// prevent race conditions. function could be called from scheduled env.
if (canSuspend) exitWith {
    [CBA_fnc_addKeybind, _this] call CBA_fnc_directCall;
};

params [
    ["_addonArg", "", ["", []]],
    ["_addonAction", "", [""]],
    ["_title", "", ["", []]],
    ["_downCode", {}, [{}, ""]],
    ["_upCode", {}, [{}, ""]],
    ["_defaultKeybind", KEYBIND_NULL, [KEYBIND_NULL]],
    ["_holdKey", false, [false]],
    ["_holdDelay", 0, [0]],
    ["_overwrite", false, [false]]
];

_addonArg params [["_addon", "", [""]], ["_subcategory", "", [""]]];
_title params [["_displayName", _addonAction, [""]], ["_tooltip", "", [""]]];
private _action = toLower format ["%1$%2", _addon, _addonAction];

// support old format
if (_defaultKeybind isEqualTypeParams [0, false, false, false]) then {
    _defaultKeybind params ["_defaultKey", "_defaultShift", "_defaultControl", "_defaultAlt"];
    _defaultKeybind = [_defaultKey, [_defaultShift, _defaultControl, _defaultAlt]];
};

// Handle non-code type being passed for up/down code args
if (!(_downCode isEqualType {})) then {
    if (_downCode isNotEqualTo "") then {WARNING_1("_downCode: Non code type [%1] will be ignored",_downCode);};
    _downCode = {};
};
if (!(_upCode isEqualType {})) then {
    if (_upCode isNotEqualTo "") then {WARNING_1("_upCode: Non code type [%1] will be ignored",_upCode);};
    _upCode = {};
};

// Make sure modifer is set to true, if base key is a modifier
_defaultKeybind params [["_defaultKey", 0, [0]], ["_defaultModifiers", [], [[]]]];
_defaultModifiers params [["_defaultShift", false, [false]], ["_defaultControl", false, [false]], ["_defaultAlt", false, [false]]];

if (_defaultKey > 0x10D) then {
    WARNING_2("Keybind %1's default keybind is invalid [DIK: %2]",_action,_defaultKey);
    _defaultKey = 0;
};
_defaultKey = _defaultKey max 0;

if (_defaultKey in [DIK_LSHIFT, DIK_RSHIFT]) then {
    _defaultShift = true;
};

if (_defaultKey in [DIK_LCONTROL, DIK_RCONTROL]) then {
    _defaultControl = true;
};

if (_defaultKey in [DIK_LMENU, DIK_RMENU]) then {
    _defaultAlt = true;
};

private _keybind = [_defaultKey, [_defaultShift, _defaultControl, _defaultAlt]];

// get a local copy of the keybind registry
private _registry = profileNamespace getVariable QGVAR(registry_v3);

if (isNil "_registry") then {
    _registry = HASH_NULL;
    profileNamespace setVariable [QGVAR(registry_v3), _registry];
};

private _keybinds = [_registry, _action] call CBA_fnc_hashGet;

// action doesn't exist in registry yet, create it and store default keybinding
if (isNil "_keybinds" || {_overwrite}) then {
    _keybinds = [_keybind];
    [_registry, _action, _keybinds] call CBA_fnc_hashSet;
};

// filter out null binds
_keybinds = _keybinds select {_x select 0 > DIK_ESCAPE};

// make list of active mods and keybinds for gui
if (isNil QGVAR(addons)) then {
    GVAR(addons) = [] call CBA_fnc_createNamespace;
    GVAR(actions) = [] call CBA_fnc_createNamespace;
};

private _addonInfo = GVAR(addons) getVariable _addon;

if (isNil "_addonInfo") then {
    _addonInfo = [_addon, []];
    GVAR(addons) setVariable [_addon, _addonInfo];
};

(_addonInfo select 1) pushBackUnique toLower _addonAction;

GVAR(actions) setVariable [_action, [_displayName, _tooltip, _keybinds, _defaultKeybind, _downCode, _upCode, _holdKey, _holdDelay, _subcategory]];

// add this action to all keybinds
{
    _keybind = _x;

    if (_downCode isNotEqualTo {}) then {
        [_keybind select 0, _keybind select 1, _downCode, "keyDown", format ["%1_down_%2", _action, _forEachIndex], _holdKey, _holdDelay] call CBA_fnc_addKeyHandler;
    };

    if (_upCode isNotEqualTo {}) then {
        [_keybind select 0, _keybind select 1, _upCode, "keyUp", format ["%1_up_%2", _action, _forEachIndex]] call CBA_fnc_addKeyHandler;
    };
} forEach _keybinds;

// Emit an event that a key has been registered.
[QGVAR(registerKeybind), _this] call CBA_fnc_localEvent;

_keybind // only return the last keybind for bwc
```


First off, let's take a look at where `GVAR(actions)` is given a value.

```sqf
if (isNil QGVAR(addons)) then {
    GVAR(addons) = [] call CBA_fnc_createNamespace;
    GVAR(actions) = [] call CBA_fnc_createNamespace;
};
```

From this, we can see that it is a common `namespace` that CBA likes to make.
CBA does this thing where they use virtual location objects, created with
[createLocation], to store variables like another namespace. This is to isolate
their functions from other mods and prevent collisions.

So 'actions' is a location object. From here we can take a few approaches, w
e could try to trick the game into pre-defining actions as another namespace 
(such as `uiNamespace`). This is difficult because locations and namespaces do 
not line up 1 to 1. We'll likely run into an issue.

The approach I decided to take from here was to figure out what sets the value 
of keybinds in the 'actions' namespace.

Take a look at this next snippet from `CBA_fnc_addKeybind`:

```sqf
GVAR(actions) setVariable [_action, [_displayName, _tooltip, _keybinds, _defaultKeybind, _downCode, _upCode, _holdKey, _holdDelay, _subcategory]];
```

Here we set the action, and give it some keybinds in index 2.
So if we can somehow modify the incoming `_keybinds` variable, we can 
still exploit this. Looking farther up, we can see it being used. 

> Note that this snippet contains a lot of the content discussed below.

```sqf
private _registry = profileNamespace getVariable QGVAR(registry_v3); //--- cba_keybinding_registry_v3

if (isNil "_registry") then {
    _registry = HASH_NULL; //["#CBA_HASH#", [], [], nil]
    profileNamespace setVariable [QGVAR(registry_v3), _registry];
};

private _keybinds = [_registry, _action] call CBA_fnc_hashGet; //loook in registry index 1 for our key, and return the value from the index in registry index 2

if (isNil "_keybinds" || {_overwrite}) then {
    _keybinds = [_keybind];
    [_registry, _action, _keybinds] call CBA_fnc_hashSet; //this will set our registry (ie, our profilenamespace) if overwrite or null
};

_keybinds = _keybinds select {_x select 0 > DIK_ESCAPE};
```

`_keybinds` comes from CBA's `CBA_fnc_hashGet` method. 
It is then checked for default (or overwrite) and possibly overwritten. 
If the TFAR keybind is overwritten, this is game over, we can't exploit it. 
So before moving on, let's just make sure we're not overwriting the preset 
value from CBA. In TFAR, we can find the `CBA_fnc_addKeybind` call for 
`LRTransmit` in `fn_ClientInit.sqf`.

```sqf
[
	"TFAR",
	"LRTransmit",
	["LR Transmit","LR Transmit"],
	{call TFAR_fnc_onLRTangentPressed},
	{call TFAR_fnc_onLRTangentReleased},
	[TF_tangent_lr_scancode, TF_tangent_lr_modifiers],
	false
] call cba_fnc_addKeybind;
```

Looking here, it seems like only a few parameters are passed. 
Taking a look back at `CBA_fnc_addKeybind`, we can see `_overwrite` is defaulted
to `FALSE`.

```sqf
params [
    ["_addonArg", "", ["", []]],
    ["_addonAction", "", [""]],
    ["_title", "", ["", []]],
    ["_downCode", {}, [{}, ""]],
    ["_upCode", {}, [{}, ""]],
    ["_defaultKeybind", KEYBIND_NULL, [KEYBIND_NULL]],
    ["_holdKey", false, [false]],
    ["_holdDelay", 0, [0]],
    ["_overwrite", false, [false]]
];
```
Okay, so as long as the `CBA_fnc_hashGet` returns a valid keybind, 
the data will be inserted and we can exploit the lazy eval.
Take a quick look in `CBA_fnc_addKeybind` where `CBA_fnc_hashGet` is called.
We can see two parameters passed in, `_registry` and `_action`. 
We already know `_action` is our action string, so lets look above where 
`_registry` is assigned a value.

We can see that `_registry` comes directly from the `profilenamespace`! 
This is terrific. Any exploit that runs back into `profilenamespace` or 
`uinamespace` is one that we can really abuse! We can also see that if a value
is not set, then a default is given (line # 64-67). 
Okay last thing to do is know how `CBA_fnc_hashGet` pulls our keybinds from the registry.

```sqf
#include "script_component.hpp"
#include "script_hashes.hpp"

SCRIPT(hashGet);

// -----------------------------------------------------------------------------
params [["_hash", [], [[]]], "_key"];

private _index = (_hash select HASH_KEYS) find _key; //HASH_KEYS == 1

if (_index >= 0) then {
    (_hash select HASH_VALUES) select _index // Return. //HASH_VALUES == 2
} else {
    private _default = param [2, _hash select HASH_DEFAULT_VALUE];

    if (isNil "_default") then {
        nil 
    } else {
        
        if (_default isEqualType []) then {
            _default = + _default;
        };
        _default 
    };  
};
```

In this, `_hash` refers to our registry (`profilenamespace`), and `_key` refers
to our action name. So we start by finding our action within the registry.
The list of action names is stored at index 1 (`HASH_KEYS`). If we sucessfully
find the action in that list, then we go pick out our Keybinds from the
list stored at index 2 (`HASH_VALUES`). This is all we care about.
Take note that we return directly from the `select` command, which keeps a
reference to the list. This will be important later on.

Okay, the last bit was quite heavy, but now we know everything
we need to successfully write exploitable code to the keybind data.
Let me line out what we know in a more effective way:

1. The data's source lies in the `profileNamespace` within the variable `cba_keybinding_registry_v3`
2. The action name is `"tfar$lrtransmit"`
3. By finding the index at `(_registry select 1)` of our action, we can find the keybind data
4. The keybind data is stored in `(_regsitry select 2)`
5. This keybind data is then moved into `GVAR(actions) getVariable (action_name)` under index 2
6. The keybind data in `CBA_fnc_getKeybind` is 1 layer deep `(select 0)`
7. This keybind data is returned in `CBA_fnc_getKeybind` under index 5
8. The keybind data is structured as `[keycode,keymods]` where `keymods` is an array of boolean values
9. If a value of `keymods` is code, TFAR should lazy evaluate it as long as either SHIFT, CTRL, or ALT, is pressed.


So now that we know all of this, we can build an exploit.

```sqf
/*
TFAR Incompetence #1
========================
Created By Lystic

https://lystic.dev
https://twitter.com/_Lystic


	Keybinds in CBA store 3 boolean values, these represent the key states of SHIFT, CTRL, and ATL

	TFAR uses fn_onLRTangetReleasedHack.sqf as a key pressed event handler. (See fn_ClientInit.sqf in TFAR)
	in this, they fail to lazy evaluate the boolean values of these key states.

	As well, these keybinds are initialized without the overwrite parameter, so any changes clients make will remain.

	With this, by inserting code into the profile namespace that contains our keybind's key states for these values, we can force 
	TFAR to execute code anytime we press a specific key (either SHIFT+CTRL or ALT)

	In this example, the SHIFT key is used.

*/

//--- load our payload into the profile namespace (many mods prevent us from accessing 3DEN)
_payload = {
	systemchat 'workin!';
};
profileNamespace setVariable ["tfar_by_lystic",_payload];

//--- this is our bad payload we'll be injecting
_bad_payload = {
	_code = profileNamespace getVariable ["tfar_by_lystic",{false}]; //get our code to execute
	with missionNamespace do {
		[] spawn _code; //run it in missionNamespacce
	};
	false; //return false (the default value from TFAR for the SHIFT key state)
};

//--- get our CBA profile (if no CBA has been laoded, then use the default)
_registry = profileNamespace getVariable ["cba_keybinding_registry_v3",["#CBA_HASH#", [], [], nil]]; 
// NOTE: there are more variables, but lrtransmit is what our POC will use
_action = "tfar$lrtransmit"; 
//--- find our action in the registry (hashGet)
_index = (_registry select 1) find _action; 
if(_index == -1) then {
	//--- action does not exist, we'll insert it!
	(_registry select 1) pushBack _action;
	(_registry select 2) pushBack [[58,[_bad_payload,true,false]]]; //TF_tangent_lr_scancode == 58 | TF_tangent_lr_modifiers == false,true,false
} else {
	//--- action exists. lets update our payload
	(_registry select 2) set[_index,[[58,[_bad_payload,true,false]]]];
};
saveprofilenamespace; //save it all :)


/*
on a final note, due to how the arrays are linked, you can do the preceeding with a single line (untested if this exact code works, but ive seen it done, so i know its possible)
NOTE: GVAR(actions) == "keybinding_actions"

((uiNamespace getVariable "keybinding_actions") getVariable _action) set [2, [[58,[_bad_payload,true,false]]]];
 */
```

Our first step is to get the registry, or create a new one, for <em>cba_keybinding_registry_v3</em>. Next, we must find our action in the registry. If our item does exist, we must set the value in the registry for that index to an exploitable payload. Remember, the payload must be an array within an array as <em>CBA_fnc_getKeybind </em>accesses index 0 before returning. If our item does not exist, we just have to push it back into the registry.

And that is it. Now if we load up a game with TFAR and press, in my example, SHIFT, it'll execute the payload.

As always, the source for my exploit can be found on my hastebin <a href="https://haste.lystic.dev/pujaqecoxi.cs" target="_blank" rel="noopener noreferrer">here</a>.

So one last thing I wanted to cover was a unique feature of this exploit. My comments throughout the screenshots have been alluding to this. The way that getKeybind and addKeybind interact with the keybind data array, the values in it are actually directly linked to the profilenamespace. I covered this a while ago with my <a href="http://lystic.net/2016/07/29/advanced-script-variable-hiding/" target="_blank" rel="noopener noreferrer">advanced variable hiding</a> post. What it allows you to do is create a single line of code for this entire exploit.

This was shown to me by a friend, and I never actually wrote it, but here is a rough take that may or may not work.

<script src="https://gist.github.com/KeganHollern/3971a5e7e58cbf184eb297951370a2d7.js"></script>

In theory, setting the value retrieved here, should link directly back to the profile, and update the profile with the new exploit. Like I said, I didn't test this, I just know that somehow it is possible.

{/* reference links */}

[Task Force Arrowhead Radio]: http://radio.task-force.ru/en/
[Lazy Eval Exploit]: https://blog.lystic.dev/lazy-eval-execution-exploit/
[createLocation]: https://community.bistudio.com/wiki/createLocation